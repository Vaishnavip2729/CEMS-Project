<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Model-Based Systems Engineering (MBSE) of an Inertial Sensor System and IC Design</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="hello_files/libs/clipboard/clipboard.min.js"></script>
<script src="hello_files/libs/quarto-html/quarto.js"></script>
<script src="hello_files/libs/quarto-html/popper.min.js"></script>
<script src="hello_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="hello_files/libs/quarto-html/anchor.min.js"></script>
<link href="hello_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="hello_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="hello_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="hello_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="hello_files/libs/bootstrap/bootstrap-8a79a254b8e706d3c925cde0a310d4f0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="hello_files/libs/quarto-diagram/mermaid.min.js"></script>
<script src="hello_files/libs/quarto-diagram/mermaid-init.js"></script>
<link href="hello_files/libs/quarto-diagram/mermaid.css" rel="stylesheet">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Model-Based Systems Engineering (MBSE) of an Inertial Sensor System and IC Design</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div style="text-align: justify;">
<section id="objective" class="level2">
<h2 class="anchored" data-anchor-id="objective">Objective</h2>
<p>IC level designing of an ACD based on ADS1115, understanding the working principle of an ADC via circuit simulations and an IC design in xschem based on SG13G2 package. SG13G2 is a 130nm process architecture based package developed by IHP.</p>
</section>
<section id="system-overview" class="level2">
<h2 class="anchored" data-anchor-id="system-overview">System Overview</h2>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div id="fig-system" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-system-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<pre class="mermaid mermaid-js" data-label="fig-system">flowchart LR
    A(ADXL335) --&gt; B(ADS1115)
    B --&gt; C(ESP8266)
    C --&gt; D{Measurement}
    D --&gt; E(Thonny Micropython)
    D --&gt; F(Arduino IDE C)
</pre>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-system-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Modular Board-Level Sensor System.
</figcaption>
</figure>
</div>
</div>
</div>
<p>The modular board-level sensor system illustrated in Figure 1 is designed for capturing and processing acceleration data using a combination of hardware and software components. The system begins with the <strong>ADXL335</strong>, a 3-axis analog accelerometer, which measures acceleration and provides an analog voltage output. This signal is then converted into a digital format by the <strong>ADS1115</strong>, a high-resolution 16-bit ADC, ensuring accurate data transmission. The <strong>ESP8266</strong>, a Wi-Fi-enabled microcontroller, receives this digitized data, processes it, and facilitates further measurement analysis. The system supports two different programming environments: <strong>Thonny MicroPython</strong>, which allows for Python-based scripting and quick prototyping, and <strong>Arduino IDE C</strong>, which enables traditional C-based firmware development. The flexibility of this system makes it highly adaptable for IoT applications, real-time monitoring, and embedded sensor-based projects, providing a reliable platform for data acquisition and wireless transmission.</p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>A Sigma-Delta (ΣΔ) Modulator is an advanced signal conversion system commonly used for high-resolution A/D and D/A conversion. It employs <strong>oversampling, quantization, and noise shaping</strong> to achieve superior performance, particularly in applications requiring precise signal representation. Unlike conventional Nyquist-rate converters, ΣΔ modulators sample the input signal at a much higher rate, reducing the need for complex anti-aliasing filters. The noise shaping technique pushes quantization noise to higher frequencies, where it can be easily removed by digital filtering, leading to a significant improvement in signal-to-noise ratio (SNR). In A/D conversion, the Sigma-Delta modulator first filters the input analog signal to remove high-frequency components, preventing aliasing. The filtered signal is then sampled at a high rate and quantized, often using a simple 1-bit or multi-bit quantizer. A feedback loop, consisting of an integrator and a digital filter, continuously adjusts the quantization error, shaping the noise spectrum. The resulting digital output, though initially at a high sampling rate, is then passed through a decimation filter, which reduces the sampling rate while maintaining high resolution. In D/A conversion, the process is reversed. A digital input sequence is converted to an analog signal using a Digital-to-Analog Converter (DAC), followed by an analog hold stage that maintains each sample value for a short duration. The output is then passed through a reconstruction filter, which smooths the signal and removes high-frequency artifacts introduced during digital processing.</p>
</section>
<section id="working-principle-of-sigma-delta-σ-modulator" class="level2">
<h2 class="anchored" data-anchor-id="working-principle-of-sigma-delta-σ-modulator">Working principle of Sigma-Delta (Σ∆) Modulator</h2>
<p>The process begins with an analog input signal, which is fed into a Sigma-Delta (ΣΔ) Modulator. This modulator operates at a significantly higher sampling rate (fₛ) compared to the Nyquist rate. The oversampling technique effectively reduces the impact of quantization noise by spreading it over a wider frequency range. A key feature of the modulator is noise shaping, which shifts quantization noise to higher frequencies, where it can be filtered out in the digital domain.</p>
</section>
<section id="building-block-of-sigma-delta-σ-modulator" class="level2">
<h2 class="anchored" data-anchor-id="building-block-of-sigma-delta-σ-modulator">Building Block of Sigma-Delta (Σ∆) Modulator</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/conversion.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Conversion Process in ADC and DAC Systems.</figcaption>
</figure>
</div>
<p>Sigma-Delta modulation is widely used in high-resolution applications such as audio processing, communications, and precision measurement due to its ability to reduce quantization noise and enhance signal quality. In A/D conversion, the analog input signal first undergoes anti-alias filtering, which removes unwanted high-frequency components that could cause aliasing during sampling. The filtered signal is then sampled at a high rate, often exceeding the Nyquist rate, capturing discrete points of the waveform. This sampled signal is then quantized, where each sample is assigned a digital value, producing a sequence such as 2, 7, 0, 15, etc. The high sampling rate and noise shaping techniques used in Sigma-Delta modulation push quantization noise to higher frequencies, improving resolution after digital filtering.</p>
<p>The D/A conversion process reverses this operation. The digital sequence is first converted back into an analog signal using a Digital-to-Analog Converter (DAC). Since the DAC output consists of discrete steps, an analog hold stage maintains each sample value momentarily. This is followed by a reconstruction filter, which smooths the signal, removing high-frequency components and restoring the continuous analog waveform. By utilizing oversampling and noise shaping, Sigma-Delta modulators achieve higher accuracy and lower distortion than conventional converters. These characteristics make them ideal for applications requiring high dynamic range and low power consumption, such as audio codecs, RF systems, and industrial sensors.</p>
</section>
<section id="behavioural-model-of-sigma-delta-modulator" class="level2">
<h2 class="anchored" data-anchor-id="behavioural-model-of-sigma-delta-modulator">Behavioural Model of Sigma-Delta Modulator</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/delta.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: Block diagram of Sigma-Delta Modulator.</figcaption>
</figure>
</div>
<p>The Sigma-Delta (ΣΔ) Modulator is an essential technique for high-resolution analog-to-digital (A/D) conversion, widely used in applications such as audio processing, biomedical instrumentation, and communication systems. The behavioral model of a Sigma-Delta Modulator consists of two primary components: an oversampling modulator and a digital/decimation filter, both working together to produce a high-resolution digital output. The process begins with an analog input signal that enters the ΣΔ Modulator, which operates at a significantly higher sampling rate (fₛ) than the Nyquist rate. This technique, known as oversampling, helps distribute quantization noise across a broader frequency range. Inside the modulator, a feedback loop with a loop filter and a quantizer processes the input signal, shaping the quantization noise by pushing it to higher frequencies, a process referred to as noise shaping. The output of the ΣΔ Modulator is a high-rate digital signal containing substantial high-frequency noise, which is then refined through a digital filter and a decimator. The digital filter removes unwanted high-frequency components, while the decimator reduces the sampling rate from fₛ to fᴅ, optimizing the signal for further processing while maintaining high resolution.</p>
<p>The block diagram illustrates this process step by step. The analog input first enters the ΣΔ Modulator, which operates at a high sampling rate (fₛ) to perform noise shaping and quantization. The resulting high-frequency digital signal then passes through a digital filter, which smooths the data by eliminating unnecessary noise. After filtering, the decimator reduces the sampling rate to an optimal data rate (fᴅ) while preserving signal integrity, ultimately producing a high-resolution digital output. The decimation ratio (fₛ / fᴅ) determines the extent of data rate reduction, ensuring efficient conversion.</p>
<p>The Sigma-Delta Modulator offers several advantages over conventional ADC methods. It achieves high resolution through oversampling and noise shaping, effectively minimizing quantization noise. Unlike traditional ADCs that rely on precise analog components, the ΣΔ Modulator leverages digital signal processing, simplifying circuit design and improving power efficiency. Due to its low power consumption and superior noise performance, it is widely used in applications such as high-fidelity audio ADCs and DACs, biomedical monitoring systems (e.g., ECG and EEG devices), industrial sensor measurements, and wireless communication receivers. Therefore, the Sigma-Delta Modulator is a highly effective method for A/D conversion, providing a high-resolution, low-noise digital output. The block diagram effectively illustrates its functionality, highlighting how the combination of oversampling, noise shaping, digital filtering, and decimation achieves superior signal processing performance. This makes Sigma-Delta Modulators the preferred choice for applications requiring precision, efficiency, and low power consumption in modern audio, medical, industrial, and communication technologies.</p>
</section>
<section id="simulink-implementation-of-1st-order-sigma-delta-modulator" class="level2">
<h2 class="anchored" data-anchor-id="simulink-implementation-of-1st-order-sigma-delta-modulator">Simulink Implementation of 1st order Sigma-Delta Modulator</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/sim1.png" class="img-fluid figure-img"></p>
<figcaption>Figure 4: Simulink Model for First Order Sigma-Delta Modulator.</figcaption>
</figure>
</div>
<p>The Simulink implementation of a first-order Sigma-Delta (ΣΔ) Modulator, a widely used technique in analog-to-digital conversion (ADC) and digital signal processing (DSP). The system begins with an input signal, represented as u=1, which is processed through a summation block. This block subtracts the feedback signal v from the input to generate an error signal. The error signal is then passed to an integrator, whose transfer function represents a discrete-time integration process. The integrator accumulates the difference over time, effectively shaping the quantization noise.</p>
<p>Next, the signal moves to a comparator, which acts as a quantizer by converting the continuous signal into a binary output, either 0 or 1. This digital output, denoted as v, is then fed back into the summation block, closing the loop and ensuring a continuous correction of errors. The feedback mechanism plays a crucial role in noise shaping, pushing quantization noise to higher frequencies where it can be effectively filtered. The first-order Sigma-Delta Modulator utilizes oversampling to improve resolution beyond the Nyquist rate, making it suitable for applications such as high-resolution ADCs, audio processing, and sensor data conversion. While this is a first-order implementation, higher-order versions offer even better noise shaping. The fundamental advantage of this system is its ability to convert an analog input into a high-frequency stream of digital bits while minimizing quantization errors through feedback and integration.</p>
</section>
<section id="matlab-output-of-1st-order-sigma-delta-modulator" class="level2">
<h2 class="anchored" data-anchor-id="matlab-output-of-1st-order-sigma-delta-modulator">Matlab output of 1st Order Sigma-Delta Modulator</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/simop1.jpg" class="img-fluid figure-img"></p>
<figcaption>Figure 5: First-Order ΣΔ Modulator Output Signal in Time Domain.</figcaption>
</figure>
</div>
<p>The output of a first-order Sigma-Delta (ΣΔ) Modulator, depicting the relationship between the continuous input signal (u) and the modulated digital output (v) over time. The x-axis represents normalized time (t/T), while the y-axis indicates amplitude. The blue curve represents the input signal, which appears to be a low-frequency sinusoidal wave, whereas the orange signal represents the modulated output, characterized by rapid switching between +1 and -1. This high-frequency switching in the output is a key feature of Sigma-Delta modulation, where the density of these transitions varies depending on the amplitude of the input signal.</p>
<p>When the input signal reaches its peak, the output consists of a higher density of positive pulses, whereas near zero crossings, the switching between +1 and -1 becomes more balanced. Similarly, for negative amplitudes, the density of negative pulses increases. This behaviour is known as Pulse Density Modulation (PDM) and is a direct consequence of the feedback and integration mechanism in the Sigma-Delta Modulator. The high-frequency quantization noise generated by this process is shaped and pushed to higher frequencies, allowing it to be filtered effectively in post-processing.</p>
<p>This type of modulation is widely used in applications requiring high-precision analog-to-digital conversion, such as high-resolution ADCs, audio signal processing, and sensor data acquisition. The key advantage of a Sigma-Delta Modulator is that it allows a simple 1-bit quantizer to achieve high resolution through oversampling and noise shaping, making it ideal for modern digital signal processing systems.</p>
</section>
<section id="spectral-analysis-of-1st-order-sigma-delta-modulator-by-using-fft-with-osr512" class="level2">
<h2 class="anchored" data-anchor-id="spectral-analysis-of-1st-order-sigma-delta-modulator-by-using-fft-with-osr512">Spectral Analysis of 1st Order Sigma-Delta Modulator by using FFT with OSR=512</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/simsp1.jpg" class="img-fluid figure-img"></p>
<figcaption>Figure 6: DFT Spectrum of a First-Order ΣΔ Modulator Output.</figcaption>
</figure>
</div>
<p>The Spectral Analysis of a first-order Sigma-Delta Modulator using Fast Fourier Transform (FFT) with an Oversampling Ratio (OSR) of 512. The x-axis denotes the normalized frequency (f/fs), while the y-axis represents the Discrete Fourier Transform (DFT) magnitude in dBFS (decibels relative to full scale). The plot shows a strong low-frequency signal component at the leftmost part of the graph, corresponding to the desired input signal, while the rest of the spectrum contains quantization noise that increases towards higher frequencies. This noise shaping characteristic is a fundamental property of Sigma-Delta modulation, where quantization noise is pushed towards higher frequencies, making it easier to remove with a low-pass filter. The high OSR value of 512 indicates significant oversampling, which helps in reducing in-band noise and improving resolution. The plot confirms that the first-order modulator exhibits a first-order noise shaping behaviour, where the noise power increases with frequency, validating the efficiency of Sigma-Delta modulation in enhancing signal quality through oversampling and noise shaping techniques.</p>
</section>
<section id="simulink-implementation-of-2nd-order-sigma-delta-modulator" class="level2">
<h2 class="anchored" data-anchor-id="simulink-implementation-of-2nd-order-sigma-delta-modulator">Simulink Implementation of 2nd Order Sigma-Delta Modulator</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/sim2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 7: Simulink Model for Second Order Sigma-Delta Modulator.</figcaption>
</figure>
</div>
<p>An important part of high-resolution analog-to-digital conversion (ADC) is a Second-Order Sigma-Delta (ΣΔ) modulator, which is represented by this Simulink model. The modulator’s behavior is determined by scaling coefficients, a feedback loop, a comparator, and two integrators. A scaling factor b (1) is applied to the input signal (u) before it is fed into the first integrator, which then accumulates the signal and sends it to the second stage. The second integrator increases the suppression of in-band quantization noise, which further improves the noise shaping. feedback coefficients a(1) and a(2)are incorporated by both integrators, which improve performance and control system stability. The comparator receives the output of the second integrator, multiplied by c (2), and uses pulse-density modulation (PDM) to transform the continuous signal into a digital bitstream (v). The feedback loop shapes the quantization noise and makes sure the system dynamically modifies its output to follow the input signal. This second-order design offers superior noise shaping than a first-order ΣΔ modulator. It does this by moving more quantization noise to higher frequencies, where it may be filtered out, increasing the signal-to-noise ratio (SNR). Applications for this structure include precise measurement, biological signal processing, and audio ADCs.</p>
</section>
<section id="matlab-output-of-2nd-order-sigma-delta-modulator" class="level2">
<h2 class="anchored" data-anchor-id="matlab-output-of-2nd-order-sigma-delta-modulator">Matlab output of 2nd Order Sigma-Delta Modulator</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/simop2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 8: Second-Order ΣΔ Modulator Output Signal in Time Domain.</figcaption>
</figure>
</div>
<p>The output of a second-order Sigma-Delta(ΣΔ) Modulator, showing the relationship between the continuous input signal and the high-frequency modulated digital output. The x-axis represents time, while the y-axis represents amplitude, with the modulator’s output switching between +1+1+1 and −1-1−1. Compared to the first-order modulator, the second-order modulator provides improved noise shaping, leading to a more dynamic and concentrated pulse density modulation (PDM). The digital output exhibits a higher density of transitions where the input amplitude is larger and fewer transitions where the signal is near zero. This behaviour results from the double integration process, which enhances quantization noise shaping by pushing even more noise energy to higher frequencies, allowing for more effective filtering. The increased pulse clustering reduces in-band noise, improving the signal-to-noise ratio (SNR) and making the second-order Sigma-Delta Modulator suitable for high-resolution analog-to-digital conversion in applications such as audio processing and high-precision sensors.</p>
</section>
<section id="spectral-analysis-of-2nd-order-sigma-delta-modulator-by-using-fft-with-osr512" class="level2">
<h2 class="anchored" data-anchor-id="spectral-analysis-of-2nd-order-sigma-delta-modulator-by-using-fft-with-osr512">Spectral Analysis of 2nd Order Sigma-Delta Modulator by using FFT with OSR=512</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/simsp2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 9: DFT Spectrum of a First-Order ΣΔ Modulator Output.</figcaption>
</figure>
</div>
<p>The Spectral Analysis of a Second-Order Sigma-Delta (ΣΔ) Modulator using Fast Fourier Transform (FFT) with an Oversampling Ratio (OSR) of 512. The x-axis denotes the normalized frequency (f/fs), while the y-axis represents the DFT magnitude in dBFS (decibels relative to full scale). The plot shows a dominant low-frequency signal at the left most part, which corresponds to the input signal, while the rest of the spectrum is primarily quantization noise. Compared to a first-order modulator, the second-order ΣΔ modulator exhibits stronger noise shaping, with a more significant reduction in in-band quantization noise. The noise floor initially remains very low and increases at higher frequencies, pushing most of the noise energy toward the higher spectrum where it can be effectively filtered. This enhanced noise shaping behaviour improves the signal-to-noise ratio (SNR) and allows for higher resolution in analog-to-digital conversion. The results confirm that the second-order Sigma-Delta Modulator achieves better performance than the first-order modulator, making it more suitable for applications requiring high-precision signal processing, such as audio ADCs and sensor measurements.</p>
</section>
<section id="ltspice-system-design-of-1st-order-sigma-delta-modulator" class="level2">
<h2 class="anchored" data-anchor-id="ltspice-system-design-of-1st-order-sigma-delta-modulator">LTSpice System Design of 1st Order Sigma-Delta Modulator</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/spice1.png" class="img-fluid figure-img"></p>
<figcaption>Figure 10: Implementation of a First-Order ΣΔ Modulator in LTSpice.</figcaption>
</figure>
</div>
<p>In signal processing applications, the LTSpice simulation of a First-Order Sigma-Delta (ΣΔ) modulator depicted in the figure is a basic circuit for analog-to-digital conversion (ADC). To improve resolution and shape the quantization noise, the design incorporates a switched-capacitor integrator, a comparator, and a D flip-flop for feedback. To ensure accurate charge transfer and reduce clock feedthrough effects, a sequence of switches controlled by non-overlapping clock signals (phi1 and phi2) sample the analog input signal (Vin).</p>
<p>The integrator (op-amp), which is at the center of the circuit, accumulates the error between the input and feedback signal (Vfb). In the process of charge redistribution, the capacitors (Cs1 and Cl1) are essential. A comparator receives the integrator output (Vx1) and decides whether the output should be a digital “1” or “0.” The D flip-flop (A1) then latches this decision, guaranteeing a steady digital output (Vd) in time with the clock signals. By using the oversampling and noise shaping principles, the modulator continuously modifies the output bitstream to gradually resemble the input rather than immediately encoding the information.</p>
<p>The simulation configuration comprises parameter settings for the following: input frequency (80 Hz), common-mode voltage (VCM), supply voltage (VDD = 3V), and capacitor values (Cs1 =Cl1 = 1pF), 0.25pF. The .tran 40m uic command captures enough data for FFT analysis by doing a transient analysis for 40 milliseconds. By ensuring that only pertinent node voltages (such as Vx1, Vphi1, Vphi2, Vq, Vd, Vfb, and Vin) are captured, the .save command maximizes simulation efficiency. In order to dynamically modify the output and lessen in-band quantization noise, the feedback loop is essential. We can investigate quantization noise shaping, oversampling effects, and system stability using this first-order Sigma-Delta modulator implementation in LTSpice, which makes it a crucial tool for high-resolution ADC design. ΣΔ modulation is perfect for audio processing, sensor data collection, and communication systems because it uses a simpler circuit and achieves higher resolution than typical Nyquist-rate ADCs.</p>
</section>
<section id="ltspice-output-of-1st-order-sigma-delta-modulator" class="level2">
<h2 class="anchored" data-anchor-id="ltspice-output-of-1st-order-sigma-delta-modulator">LTSpice Output of 1st order Sigma-Delta Modulator</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ltspice1.png" class="img-fluid figure-img"></p>
<figcaption>Figure 11: Time-Domain Response of a First-Order ΣΔ Modulator.</figcaption>
</figure>
</div>
<p>The input and output signals of a First-Order Sigma-Delta (ΣΔ) modulator, which uses noise shaping and oversampling techniques for high-resolution analog-to-digital conversion (ADC), are represented by the graph. The analog input signal is represented by the green waveform (V(vin)), which is a sinusoidal waveform that is digitalized. In order to show how the modulator can shape quantization noise, the blue waveform (V(vq)) represents the internal quantized signal, which is influenced by the integrator and feedback loop. As the amplitude of the input signal changes, so does the density of high (1s) and low (0s) pulses in the final pulse-density modulated (PDM) output, which is represented by the red waveform (V(vd)). While the bitstream maintains a balanced distribution of 1s and 0s around zero crossings, this modulation approach guarantees that there are more 1s at higher input levels using the noise shaping concept, the ΣΔ modulator efficiently drives quantization noise to higher frequencies. This improves the in-band signal-to-noise ratio (SNR), and high-frequency noise is subsequently eliminated using low-pass decimation filtering. For low-power applications where great dynamic range and power efficiency are crucial, such as sensor interface, low-frequency audio processing, and biomedical data acquisition, this technique makes first-order ΣΔ modulators perfect.</p>
</section>
<section id="lt-spice-output-of-1st-order-sigma-delta-modulator---fft" class="level2">
<h2 class="anchored" data-anchor-id="lt-spice-output-of-1st-order-sigma-delta-modulator---fft">LT Spice Output of 1st Order Sigma-Delta Modulator - FFT</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/FFT1.png" class="img-fluid figure-img"></p>
<figcaption>Figure 12: Frequency-Domain Response of a First-Order ΣΔ Modulator</figcaption>
</figure>
</div>
<p>The output signal (Vd) from a Second-Order Sigma-Delta (ΣΔ) modulator in LTSpice is the subject of the graph’s Fast Fourier Transform (FFT) analysis. Power spectral density, measured in decibels (dB), is represented on the y-axis, while the frequency spectrum, from Hz to MHz, is represented on the x-axis. A crucial feature of second-order ΣΔ modulators, the quantization noise shaping effect is demonstrated by the FFT plot. This phenomenon causes the noise level to be pushed toward higher frequencies and drastically decreased at lower frequencies. The strong signal and low noise in the low-frequency zone (below 1 kHz) show that the band of interest is well suppressed from noise. The modulator moves quantization noise to higher frequencies where it may be readily filtered out, as evidenced by the noise floor rising as frequency rises over 10 kHz.</p>
<p>The oversampling and noise shaping effects that contribute to a high signal-to-noise ratio (SNR) in the low-frequency region are indicated by the deep notch close to 100 kHz. The presence of high-frequency quantization noise is confirmed by the growing spectral density at higher frequencies; this noise can be eliminated by using a low-pass decimation filter. This FFT analysis confirms that the second-order ΣΔ modulator effectively reduces noise, enhancing resolution in high-precision ADC applications such digital communication systems, audio processing, and sensor data collection.</p>
</section>
<section id="ltspice-system-design-of-2nd-order-sigma-delta-modulator" class="level2">
<h2 class="anchored" data-anchor-id="ltspice-system-design-of-2nd-order-sigma-delta-modulator">LTSpice System Design of 2nd Order Sigma-Delta Modulator</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/spice2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 13: Implementation of a Second-Order ΣΔ Modulator in LTSpice.</figcaption>
</figure>
</div>
<p>In high-precision analog-to-digital conversion (ADC), a second-order sigma-delta (ΣΔ) modulator is a crucial part, as shown in this LTSpice circuit diagram. A comparator, a D flip-flop, operational amplifiers, and switched-capacitor circuits are all incorporated into the design to create a feedback loop that improves quantization accuracy via noise shaping. Proper charge transfer is ensured by processing the sine wave input signal (Vin) through a switched-capacitor network that is regulated by non-overlapping clock signals (phi1 and phi2). The first step is a switched-capacitor integrator, in which the difference between the input and feedback signal (Vfb) is accumulated by capacitors (Cs1) and an operational amplifier. After that, a second integrator pushes quantization noise to higher frequencies, further fine-tuning the noise shape.</p>
<p>The analog signal is subsequently transformed into a pulse-density modulated (PDM) digital output by passing the second-stage output (Vx2) via a comparator. To provide steady output, a D flip-flop (DFF) synchronizes the bitstream (Vd) with the clock signals. By reducing quantization mistakes and increasing accuracy, the feedback loop continuously improves the signal. The transient analysis (.tran 40m uic) guarantees a 40ms simulation run without determining the DC operating point, enabling accurate modulator behavior observation. Evaluating the output using an FFT analysis aids in determining how well noise shaping and overall performance work. This second-order arrangement greatly lowers in-band quantization noise in comparison to a first-order modulator, moving it toward higher frequencies where it may be efficiently filtered.</p>
</section>
<section id="ltspice-output-of-2nd-order-sigma-delta-modulator" class="level2">
<h2 class="anchored" data-anchor-id="ltspice-output-of-2nd-order-sigma-delta-modulator">LTSpice Output of 2nd order Sigma-Delta Modulator</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/ltspice2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 14: Time-Domain Response of a Second-Order ΣΔ Modulator.</figcaption>
</figure>
</div>
<p>The input and output signals of a Second-Order Sigma-Delta (ΣΔ) modulator, a crucial design in high-resolution analog-to-digital conversion (ADC), are depicted in the graph below. This modulator uses higher-order noise shaping to achieve improved quantization error suppression. A sinusoidal waveform that has been oversampled and quantized is the analog input signal represented by the green waveform (V(vin)). The internal quantized signal is represented by the blue waveform (V(vq)), which is the result of two cascaded integrators that remove low-frequency quantization noise more efficiently than a first-order ΣΔ modulator. The last pulse-density modulated (PDM) bitstream is represented by the red waveform (V(vd)), in which the input amplitude is dynamically correlated with the density of 1s and 0s. By redistributing more quantization noise to higher frequencies, the second-order structure improves noise shaping and raises the in-band signal-to-noise ratio (SNR). This, when paired with a decimation filter, produces a more accurate and smooth digital representation of the input signal. The second-order ΣΔ modulator achieves higher effective resolution in applications that need high dynamic range, like precision instrumentation, high-fidelity audio processing, and biomedical signal collection, since it has steeper noise shaping than a first-order modulator.</p>
</section>
<section id="lt-spice-output-of-2nd-order-sigma-delta-modulator---fft" class="level2">
<h2 class="anchored" data-anchor-id="lt-spice-output-of-2nd-order-sigma-delta-modulator---fft">LT Spice Output of 2nd Order Sigma-Delta Modulator - FFT</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/FFT2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 15: Frequency-Domain Response of a Second-Order ΣΔ Modulator</figcaption>
</figure>
</div>
<p>The Fast Fourier Transform (FFT) analysis of the output signal (Vd) from a First-Order Sigma-Delta (ΣΔ) modulator that was simulated in LTSpice is shown in this graph. While the y-axis displays the power spectral density in decibels (dB), the x-axis depicts the frequency domain, which spans from Hz to MHz. Quantization noise is reduced at low frequencies and redistributed toward higher frequencies in the FFT output, illustrating the fundamental noise shaping property of a first-order ΣΔ modulator. The signal is still strong and has a lower noise level in the lower frequency range (below 1 kHz), guaranteeing accurate representation in this band. Nevertheless, noise levels sharply increase when the frequency rises over 10 kHz, suggesting that first-order modulators offer less noise reduction than higher-order systems.</p>
<p>The oversampling and feedback effect that helps increase the signal-to-noise ratio (SNR) in the required frequency range is suggested by the presence of a notch close to 100 kHz. A low-pass decimation filter is required to extract the useable signal because of the growing noise at high frequencies. This FFT demonstrates that although the first-order ΣΔ modulator suppresses low-frequency noise effectively, it provides less aggressive noise shaping than a second-order modulator. As a result, it is appropriate for low-to-moderate resolution ADC applications like sensor interfacing, simple digital signal processing, and basic audio conversion.</p>
</section>
</div>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>